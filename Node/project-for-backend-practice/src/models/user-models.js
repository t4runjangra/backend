//import mongoose and Schema from mongoose
import mongoose, { Schema } from "mongoose";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import crypto from "crypto";


const userSchema = new Schema({
    avatar: {
        type: {
            url: String,
            localPath: String
        },
        default: {
            url: `https://placehold.co/200x200`,
            localPath: ""
        }
    },
    username: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        trim: true,
        index: true
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        trim: true,
    },
    fullName: {
        type: String,
        trim: true,
    },
    password: {
        type: String,
        required: [true, "Password is Required"],
    },
    isEmailVerified: {
        type: Boolean,
        default: false
    },
    refreshToken: {
        type: String
    },
    forgotPasswordToken: {
        type: String
    },
    forgotPasswordExpiry: {
        type: Date
    },
    emailVerificationToken: {
        type: String
    },
    emailVerificationExpiry: {
        type: Date
    }
}, {
    timestamps: true
}
)

userSchema.pre("save", async function (next) {
    if (!this.isModified("password")) return next()

    this.password = await bcrypt.hash(this.password, 10)
    next()
})

//methods in Schema
userSchema.methods.isPasswordCorrect = async function (password) {
    // stringfy it before using because the password came as in the form of string
    return await bcrypt.compare(String(password), String(this.password))
}

userSchema.methods.generateAccessToken = function () {
    return jwt.sign(
        //this is a payload
        {
            _id: this._id, //automatically generated by mongoDB _id
            email: this.email,
            username: this.username
        },
        process.env.ACCESS_TOKEN_SECRET,
        {
            expiresIn: process.env.ACCESS_TOKEN_EXPIRY
        }

    )
}

userSchema.methods.generateRefreshToken = function () {
    return jwt.sign({
        _id: this._id,
        email: this.email,
        username: this.username
    }, process.env.REFRES_TOKEN_SECRET, {
        expiresIn: process.env.REFRES_TOKEN_EXPIRY
    })
}

userSchema.methods.generateTemporaryToken = function () {

    const unHashedToken = crypto.randomBytes(20).toString("hex")
    const hashedToken = crypto.createHash("sha256")
        .update(unHashedToken)
        .digest("hex")

    const tokenExpiry = Date.now() + (20 * 60 * 1000)

    return { unHashedToken, hashedToken, tokenExpiry }

}



export const User = mongoose.model("user", userSchema)



/*JWT also known as JSON web token is used for encryption of the communication the client and the server is having it is a secure way of sending information. jwt is in string format 

jwt structure 
the jwt is divided into three parts which are

1 header
2 payload
3 signature 

the header store the info like which algorithm is using and what is the type of token it kind of provide metadata means data about data

{
    "algo":"HS256",
    "type":"jwt"
}

it uses a base64url for safety

after that it just become a long string 

the second part is payload where the actual data mean the info about the user is stored also known as claim ,

some additional information like timestamp which includes when it was issued and when it will going to expire 

also stored in JSON format use base64Url encoding


the third part is signature ensure the token integrity(genuine/honesty) using the header payload and a secret
key 


here we have two algorithm used in jwt Which is HS256 and rs265 

HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
)

the final jwt token looks like this 
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNzA4MzQ1MTIzLCJleHAiOjE3MDgzNTUxMjN9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

header.payload.secret/signature just a long ass string 

how it works 

when a user come to the website or we can say the client side user send a request to the server the server create a jwt and return it to the user which have its time stamp mean for this much time a user can stay here after that he has to request a new token from the server 
after generating the jwt further request done with jwt  */